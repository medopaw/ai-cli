use anyhow::{anyhow, Context, Result};
use std::process::Command;

/// Represents a segment of diff content for parallel processing
#[derive(Debug, Clone)]
pub struct DiffSegment {
    pub files: Vec<String>,    // List of files included in this segment
    pub content: String,       // Complete diff content for this segment
    pub char_count: usize,     // Character count for this segment
}

/// Summary of changes for a single file generated by AI
#[derive(Debug, Clone)]
pub struct FileSummary {
    pub filename: String,      // File path
    pub summary: String,       // AI-generated change summary
}

/// Statistics about the overall diff
#[derive(Debug, Clone)]
pub struct DiffStats {
    pub files_changed: usize,
    pub lines_added: usize,
    pub lines_deleted: usize,
    pub file_types: Vec<String>, // Primary file types found
}

pub struct GitOperations;

impl GitOperations {
    pub fn is_git_repo() -> bool {
        Command::new("git")
            .args(["rev-parse", "--git-dir"])
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false)
    }

    pub fn get_staged_diff() -> Result<String> {
        let output = Command::new("git")
            .args(["diff", "--staged"])
            .output()
            .context("Failed to run git diff --staged")?;

        if !output.status.success() {
            return Err(anyhow!("git diff --staged failed"));
        }

        Ok(String::from_utf8(output.stdout)?)
    }

    #[allow(dead_code)]
    pub fn get_unstaged_diff() -> Result<String> {
        let output = Command::new("git")
            .args(["diff"])
            .output()
            .context("Failed to run git diff")?;

        if !output.status.success() {
            return Err(anyhow!("git diff failed"));
        }

        Ok(String::from_utf8(output.stdout)?)
    }

    pub fn get_status() -> Result<String> {
        let output = Command::new("git")
            .args(["status", "--porcelain"])
            .output()
            .context("Failed to run git status")?;

        if !output.status.success() {
            return Err(anyhow!("git status failed"));
        }

        Ok(String::from_utf8(output.stdout)?)
    }

    pub fn has_staged_changes() -> Result<bool> {
        let diff = Self::get_staged_diff()?;
        Ok(!diff.trim().is_empty())
    }

    pub fn has_unstaged_changes() -> Result<bool> {
        let diff = Self::get_unstaged_diff()?;
        Ok(!diff.trim().is_empty())
    }

    pub fn add_all() -> Result<()> {
        let output = Command::new("git")
            .args(["add", "."])
            .output()
            .context("Failed to run git add .")?;

        if !output.status.success() {
            return Err(anyhow!("git add . failed"));
        }

        Ok(())
    }

    pub fn commit(message: &str) -> Result<()> {
        let output = Command::new("git")
            .args(["commit", "-m", message])
            .output()
            .context("Failed to run git commit")?;

        if !output.status.success() {
            let error = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("git commit failed: {}", error));
        }

        Ok(())
    }

    pub fn push() -> Result<String> {
        let output = Command::new("git")
            .args(["push"])
            .output()
            .context("Failed to run git push")?;

        if !output.status.success() {
            let error = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("git push failed: {}", error));
        }

        // Return the push output for display
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        
        // Git push typically outputs to stderr, so combine both
        let combined_output = if !stderr.is_empty() {
            stderr.to_string()
        } else if !stdout.is_empty() {
            stdout.to_string()
        } else {
            "Everything up-to-date".to_string()
        };

        Ok(combined_output.trim().to_string())
    }

    pub fn push_force() -> Result<String> {
        let output = Command::new("git")
            .args(["push", "-f"])
            .output()
            .context("Failed to run git push -f")?;

        if !output.status.success() {
            let error = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("git push -f failed: {}", error));
        }

        // Return the push output for display
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        
        // Git push typically outputs to stderr, so combine both
        let combined_output = if !stderr.is_empty() {
            stderr.to_string()
        } else if !stdout.is_empty() {
            stdout.to_string()
        } else {
            "Everything up-to-date".to_string()
        };

        Ok(combined_output.trim().to_string())
    }

    pub fn has_remote() -> bool {
        Command::new("git")
            .args(["remote"])
            .output()
            .map(|output| output.status.success() && !output.stdout.is_empty())
            .unwrap_or(false)
    }

    pub fn has_upstream() -> bool {
        Command::new("git")
            .args(["rev-parse", "--abbrev-ref", "@{upstream}"])
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false)
    }

    pub fn set_upstream(remote: &str, branch: &str) -> Result<()> {
        let output = Command::new("git")
            .args(["push", "-u", remote, branch])
            .output()
            .context("Failed to set upstream")?;

        if !output.status.success() {
            let error = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Failed to set upstream: {}", error));
        }

        Ok(())
    }

    pub fn get_current_branch() -> Result<String> {
        let output = Command::new("git")
            .args(["branch", "--show-current"])
            .output()
            .context("Failed to get current branch")?;

        if !output.status.success() {
            return Err(anyhow!("Failed to get current branch"));
        }

        Ok(String::from_utf8(output.stdout)?.trim().to_string())
    }

    pub fn add_remote(name: &str, url: &str) -> Result<()> {
        let output = Command::new("git")
            .args(["remote", "add", name, url])
            .output()
            .context("Failed to add remote")?;

        if !output.status.success() {
            let error = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!("Failed to add remote: {}", error));
        }

        Ok(())
    }

    pub fn get_repository_name() -> Result<String> {
        let current_dir = std::env::current_dir()
            .context("Failed to get current directory")?;
        
        let repo_name = current_dir
            .file_name()
            .context("Failed to get directory name")?
            .to_string_lossy()
            .to_string();

        Ok(repo_name)
    }

    /// Segment a large diff by files for parallel AI processing
    pub fn segment_diff_by_files(diff: &str, max_length: usize) -> Vec<DiffSegment> {
        let mut segments = Vec::new();
        let mut current_segment_files = Vec::new();
        let mut current_segment_content = String::new();
        let mut current_char_count = 0;

        // Split diff by file boundaries
        let file_diffs = Self::split_diff_by_files(diff);

        for (filename, file_diff) in file_diffs {
            let file_diff_len = file_diff.len();
            
            // If this single file exceeds max_length, it gets its own segment
            if file_diff_len > max_length {
                // First, finish current segment if it has content
                if !current_segment_content.is_empty() {
                    segments.push(DiffSegment {
                        files: current_segment_files.clone(),
                        content: current_segment_content.clone(),
                        char_count: current_char_count,
                    });
                    current_segment_files.clear();
                    current_segment_content.clear();
                    current_char_count = 0;
                }
                
                // Add the large file as its own segment
                segments.push(DiffSegment {
                    files: vec![filename],
                    content: file_diff,
                    char_count: file_diff_len,
                });
            } else if current_char_count + file_diff_len > max_length {
                // Current segment is full, start a new one
                if !current_segment_content.is_empty() {
                    segments.push(DiffSegment {
                        files: current_segment_files.clone(),
                        content: current_segment_content.clone(),
                        char_count: current_char_count,
                    });
                    current_segment_files.clear();
                    current_segment_content.clear();
                    current_char_count = 0;
                }
                
                // Start new segment with this file
                current_segment_files.push(filename);
                current_segment_content.push_str(&file_diff);
                current_char_count += file_diff_len;
            } else {
                // Add to current segment
                current_segment_files.push(filename);
                current_segment_content.push_str(&file_diff);
                current_char_count += file_diff_len;
            }
        }

        // Add final segment if it has content
        if !current_segment_content.is_empty() {
            segments.push(DiffSegment {
                files: current_segment_files,
                content: current_segment_content,
                char_count: current_char_count,
            });
        }

        segments
    }

    /// Split diff content by individual files
    fn split_diff_by_files(diff: &str) -> Vec<(String, String)> {
        let mut files = Vec::new();
        let mut current_file = String::new();
        let mut current_content = String::new();
        
        for line in diff.lines() {
            if line.starts_with("diff --git") {
                // Save previous file if exists
                if !current_file.is_empty() && !current_content.is_empty() {
                    files.push((current_file.clone(), current_content.clone()));
                }
                
                // Extract filename from "diff --git a/path/file b/path/file"
                if let Some(file_part) = line.split_whitespace().nth(2) {
                    current_file = if file_part.starts_with("a/") {
                        file_part[2..].to_string()
                    } else {
                        file_part.to_string()
                    };
                } else {
                    current_file = "unknown".to_string();
                }
                
                current_content.clear();
                current_content.push_str(line);
                current_content.push('\n');
            } else {
                current_content.push_str(line);
                current_content.push('\n');
            }
        }
        
        // Add the last file
        if !current_file.is_empty() && !current_content.is_empty() {
            files.push((current_file, current_content));
        }
        
        files
    }

    /// Generate overall statistics for a diff
    pub fn generate_diff_stats(diff: &str) -> DiffStats {
        let lines: Vec<&str> = diff.lines().collect();
        let mut files_changed = std::collections::HashSet::new();
        let mut lines_added = 0;
        let mut lines_deleted = 0;
        let mut file_extensions = std::collections::HashSet::new();

        for line in lines {
            if line.starts_with("diff --git") {
                // Extract filename and extension
                if let Some(file_part) = line.split_whitespace().nth(2) {
                    let filename = if file_part.starts_with("a/") {
                        &file_part[2..]
                    } else {
                        file_part
                    };
                    
                    files_changed.insert(filename.to_string());
                    
                    // Extract file extension for type analysis
                    if let Some(ext) = filename.split('.').last() {
                        if ext != filename && !ext.is_empty() {
                            file_extensions.insert(ext.to_string());
                        }
                    }
                }
            } else if line.starts_with('+') && !line.starts_with("+++") {
                lines_added += 1;
            } else if line.starts_with('-') && !line.starts_with("---") {
                lines_deleted += 1;
            }
        }

        DiffStats {
            files_changed: files_changed.len(),
            lines_added,
            lines_deleted,
            file_types: file_extensions.into_iter().collect(),
        }
    }

}